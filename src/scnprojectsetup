#!/usr/bin/env python3

import sys
import os
import argparse
import json
import shutil
import re

from socket import gethostname
from pwd import getpwuid
from datetime import datetime
from subprocess import check_output

ASCII_ERROR_BANNER = r"""   ______    ______   __    __        _______                                                     __       ______              __                         
 /      \  /      \ |  \  |  \      |       \                                                   |  \     /      \            |  \                        
|  $$$$$$\|  $$$$$$\| $$\ | $$      | $$$$$$$\  ______    ______       __   ______    _______  _| $$_   |  $$$$$$\  ______  _| $$_    __    __   ______  
| $$___\$$| $$   \$$| $$$\| $$      | $$__/ $$ /      \  /      \     |  \ /      \  /       \|   $$ \  | $$___\$$ /      \|   $$ \  |  \  |  \ /      \ 
 \$$    \ | $$      | $$$$\ $$      | $$    $$|  $$$$$$\|  $$$$$$\     \$$|  $$$$$$\|  $$$$$$$ \$$$$$$   \$$    \ |  $$$$$$\\$$$$$$  | $$  | $$|  $$$$$$\
 _\$$$$$$\| $$   __ | $$\$$ $$      | $$$$$$$ | $$   \$$| $$  | $$    |  \| $$    $$| $$        | $$ __  _\$$$$$$\| $$    $$ | $$ __ | $$  | $$| $$  | $$
|  \__| $$| $$__/  \| $$ \$$$$      | $$      | $$      | $$__/ $$    | $$| $$$$$$$$| $$_____   | $$|  \|  \__| $$| $$$$$$$$ | $$|  \| $$__/ $$| $$__/ $$
 \$$    $$ \$$    $$| $$  \$$$      | $$      | $$       \$$    $$    | $$ \$$     \ \$$     \   \$$  $$ \$$    $$ \$$     \  \$$  $$ \$$    $$| $$    $$
  \$$$$$$   \$$$$$$  \$$   \$$       \$$       \$$        \$$$$$$__   | $$  \$$$$$$$  \$$$$$$$    \$$$$   \$$$$$$   \$$$$$$$   \$$$$   \$$$$$$ | $$$$$$$ 
                                                                |  \__/ $$                                                                     | $$      
                                                                 \$$    $$                                                                     | $$      
                                                                  \$$$$$$                                                                       \$$      
                                                                 \$$$$$$                                                                       \$$                                                            
"""

class ProjectSetup():

    def __init__(self):

        self.version = '1.9.3'

        # get the config file
        here = str(os.path.dirname(os.path.realpath(__file__)))
        json_config = os.path.join(here,'config.json')

        # initialise None variables that are defined inside functions
        self.project_types = None
        self.project_type_descriptions = None

        # initialise the config file and get user arguments
        self.config = self._initConfig(json_config)
        self.args = self._parser(json_config)

        # Episodic support: prompt for season/episode if type is 'eps'
        self.season = None
        self.episode_count = None
        if self.args.type == 'eps':
            try:
                self.season = int(input('Enter season number (e.g., 1): ').strip())
                self.episode_count = int(input('Enter number of episodes: ').strip())
                if self.season < 1 or self.episode_count < 1:
                    raise ValueError
                if self.episode_count > 100:
                    print('Take a walk PÃ¥l. This is too much...')
                    sys.exit(1)
            except Exception:
                print('Invalid season or episode count. Project creation cancelled.')
                sys.exit(1)

        # Derive a consistent project folder name that can be reused across project types
        self.original_project_name = self.args.name
        self.series_base_name = self.original_project_name
        if self.args.type == 'eps' and self.season is not None:
            suffix_match = re.match(r'^(?P<base>.+)_s(?P<season>\d{2})$', self.original_project_name)
            if suffix_match:
                inferred_base = suffix_match.group('base')
                inferred_season = int(suffix_match.group('season'))
                if inferred_season != self.season:
                    print('Season number conflict between project name and input. Project creation cancelled.')
                    sys.exit(1)
                self.series_base_name = inferred_base
            else:
                self.series_base_name = self.original_project_name
            self.project_folder_name = f"{self.series_base_name}_s{self.season:02d}"
        else:
            self.project_folder_name = self.original_project_name

        # process the arguments
        self.destination, self.project_type, self.original_type = self._processArgs(self.args, self.project_types)
        if self.args.type == 'eps':
            destination_root = os.path.dirname(self.destination)
            self.destination = os.path.join(destination_root, self.project_folder_name)
            self.paths = self._getEpisodicProjectPaths(self.destination, self.series_base_name, self.season, self.episode_count)
        else:
            self.paths = self._getProjectPaths(self.original_type, self.destination)

        # create the project as specified
        self._createProject(self.paths)

        # Always create log files after folder creation
        project_file = self._touchProjectFile(self.destination)
        self._pipeProjectInfo(project_file)
        self._duplicateProjectFile(project_file)

        # return info that the project was successfully created
        print(f"{self.args.type} project '{self.project_folder_name}' was successfully created at {self.destination}")

    def _getEpisodicProjectPaths(self, destination, series_name, season, episode_count):
        base_paths, dynamic_folders, _ = self._collectFolderTemplates('eps')
        formatted_paths = base_paths + [df.format(name=self.project_folder_name, type='eps') for df in dynamic_folders]
        formatted_paths = self._unique(formatted_paths)

        season_root = destination  # For episodic projects, destination already points at the season folder
        project_paths = [season_root]

        for ep in range(1, episode_count + 1):
            episode_folder = f"{series_name}_s{season:02d}e{ep:02d}"
            episode_root = os.path.join(season_root, episode_folder)
            project_paths.append(episode_root)
            for base in formatted_paths:
                project_paths.append(os.path.join(episode_root, base))

        common_root = os.path.join(season_root, '_common')
        project_paths.append(common_root)
        for base in formatted_paths:
            project_paths.append(os.path.join(common_root, base))

        return project_paths

    def _initConfig(self,json_config):
        # load the json file into memory as a dictionary
        with open(json_config, 'r', encoding='utf-8') as json_data:
            config = json.load(json_data)

        # get all the project types and descriptions
        project_types = sorted(config['project_types'].keys())
        project_type_descriptions = []
        for i in project_types:
            description = config['project_types'][i]['description']
            project_type_descriptions.append('({0})'.format(description))

        self.project_types = project_types
        self.project_type_descriptions = project_type_descriptions

        return config


    def _dirtyString(self, string):
        # only allow lowercase and underscore
        clean_string_verification = 'abcdefghijklmnopqrstuvwxyz_-0123456789'
        clean_string = ''.join([x for x in string if x in clean_string_verification])
        # check for uppercase letters or only numbers
        if string.isdigit():
            return 1 # cannot be only numbers
        elif string.isupper() or not (string.isupper() or string.islower()):
            return 2 # must be only lowercase
        elif len(clean_string) != len(string):
            return 3 # cannot contain symbols not included in clean_string_verification
        else:
            return False


    def _buildTypeString(self):
        type_string = ''
        for x in zip(self.project_types, self.project_type_descriptions):
            type_string += '\t'.join(x) + '\n'

        return type_string


    def _parser(self, json_config):
        parser = argparse.ArgumentParser(
            prog = 'scnprojectsetup',
            formatter_class = argparse.RawTextHelpFormatter,
            description = 'An app that creates project folders based on a config file.',
            usage = '%(prog)s name type destination\n' +\
            'example: %(prog)s starwars ftr /Volumes/scn_ftr_04')
        parser.add_argument("name",help="Project name")
        parser.add_argument("type",help=(self._buildTypeString()))
        parser.add_argument("destination",help="Specify a destination folder"+\
                            '\n[ Tip! You can drag`n`drop destination folder from Finder ]',
                            metavar='destination')
        parser.add_argument("-v","--verbose",help='Increase output verbosity',
                            action="store_true")
        parser.add_argument("-c","--config",help='Specify a custom config file',
                            default=json_config,
                            metavar='FILE')
        if len(sys.argv) == 4:
            args = parser.parse_args()
        elif '-h' in sys.argv or '--help' in sys.argv:
            print('\nVersion: ' + self.version)
            args = parser.parse_args()
        else:
            print(ASCII_ERROR_BANNER)
            print('\nscnprojectsetup: ERROR: too few arguments\n')
            print('\nVersion: ' + self.version)
            parser.print_help()
            sys.exit(0)

        return args


    def _processArgs(self, args, project_types):
        project_type = args.type
        project_name = args.name
        verbose = args.verbose
        destination_root = args.destination
        
        # -------------------- #
        # process project_type
        # -------------------- #
        # Store original type for folder creation
        original_type = project_type
        # Strip numbers for config lookup
        base_type = ''.join([i for i in project_type if not i.isdigit()])
        
        if base_type in project_types:
            # Check if numbered suffix is valid (max 2 digits)
            if len(project_type) - len(base_type) <= 2:
                project_type = base_type  # Use base type for config
            else:
                print(f"{args.type} is not a recognised project type (number too long, max 2 digits)")
                print(f"Recognized types: {' '.join(project_types)}")
                sys.exit(0)
        else:
            print(f"{args.type} is not a recognised project type")
            print(f"Recognized types: {' '.join(project_types)}")
            sys.exit(0)

        if verbose:
            print('PROJECT TYPE: %s' % project_type)

        # -------------------- #
        # process project_name
        # -------------------- #
        dirty_code = self._dirtyString(project_name)
        if dirty_code:
            if dirty_code == 1:
                print("Project name cannot consist of purely numbers." \
                      "\nThis is not according to specification. Project creating cancelled")
            elif dirty_code == 2:
                print("Project name contains UPPERCASE letters."\
                      "\nThis is not according to specification. Project creation cancelled.")
            elif dirty_code == 3:
                print("Project name contains non-ascii characters." \
                      "\nThis is not according to specification. Project creation cancelled.")
            else:
                print("Unexpected error! Contact the TECH department!")
            sys.exit(0)

        if verbose:
            print('CONFIG FILE: %s' % args.config)

        # -------------------- #
        # process destination
        # -------------------- #
        if not os.path.isdir(destination_root):
            print(f"{destination_root} does not exist. Project not created")
            sys.exit(0)
        destination = os.path.join(destination_root,project_name)
        if verbose:
            print('DESTINATION DIR: %s' % destination)

        return destination, project_type, original_type

    def _collectFolderTemplates(self, base_type):
        """Return base and dynamic folder templates for a given project type."""
        type_config = self.config['project_types'].get(base_type, {})

        base_paths = list(self.config['default'].get('folders', []))
        base_paths.extend(type_config.get('folders', []))

        omit = set(type_config.get('omit', []))
        base_paths = [path for path in base_paths if path not in omit]

        dynamic_folders = list(self.config['default'].get('dynamic_folders', []))
        dynamic_folders.extend(type_config.get('dynamic_folders', []))

        return self._unique(base_paths), dynamic_folders, bool(type_config.get('subfolder'))

    @staticmethod
    def _unique(sequence):
        seen = set()
        result = []
        for item in sequence:
            if item not in seen:
                seen.add(item)
                result.append(item)
        return result

    def _getProjectPaths(self, path_type, path_root):
        base_type = ''.join([i for i in path_type if not i.isdigit()])
        base_paths, dynamic_folders, subfolder = self._collectFolderTemplates(base_type)

        project_paths = []
        base_root = os.path.join(path_root, path_type) if subfolder else path_root

        for path in base_paths:
            project_paths.append(os.path.join(base_root, path))

        for template in dynamic_folders:
            dynamic_folder = template.format(name=self.project_folder_name, type=self.args.type)
            project_paths.append(os.path.join(base_root, dynamic_folder))

        return project_paths

    def _createProject(self, paths):
        if self.args.type == 'eps':
            if os.path.exists(self.destination):
                print(f"{self.destination} already exists.\nNo project folders created")
                sys.exit(0)
            # For episodic, check if any episode folder already exists (direct children of series folder)
            episode_folders = set()
            for path in paths:
                # episode folder is always .../{series_folder}/{episode_folder}/...
                parts = path.split(os.sep)
                # Find the index of the series folder (destination)
                try:
                    dest_index = parts.index(os.path.basename(self.destination))
                    episode_folder = os.sep.join(parts[:dest_index+2])
                    episode_folders.add(episode_folder)
                except ValueError:
                    continue
            for folder in episode_folders:
                if os.path.exists(folder):
                    print(f"{folder} already exists.\nNo project folders created")
                    sys.exit(0)
        else:
            top_level_folder = os.path.join(self.destination, self.args.type)
            if os.path.exists(top_level_folder):
                print(f"{top_level_folder} already exists.\nNo project folders created")
                sys.exit(0)

        # If the relevant folders do not exist, proceed to create the entire folder structure
        for path in paths:
            try:
                os.makedirs(path)
            except OSError as e:
                print(f"Error: Unable to create folder {path} due to {e}.")
                sys.exit(1)


    def _touchProjectFile(self, destination):
        project_file = os.path.join(destination, ('_' + self.project_folder_name + '.txt'))
        if not os.path.isfile(project_file):
            open(project_file, 'a').close()

        return project_file


    def _pipeProjectInfo(self, project_file):
        info_string = \
            'Name of project: %s' % self.project_folder_name +\
            '\nProject path: %s' % self.destination +\
            '\nProject type: %s' % self.args.type +\
            '\nCreated with: scnprojectsetup %s' % self.version +\
            '\nCreator: %s@%s' %  (getpwuid(os.getuid()).pw_name, gethostname()) +\
            '\nCreation date: %s' % str(datetime.now())[:-7] +\
            '\n' +\
            '\nUptime at creation: %s'% check_output("uptime").decode('utf-8')+ \
            '\nMounted volumes at creation time:\n%s'% check_output(["df", "-h"]).decode('utf-8')+ \
            '\n\n==============================\n\n'

        targets = [project_file, self._getHiddenProjectFile(project_file)]
        for path in targets:
            with open(path, 'a') as handle:
                handle.write(info_string)


    def _duplicateProjectFile(self, project_file):
        hidden_file = self._getHiddenProjectFile(project_file)
        if not os.path.isfile(hidden_file) and os.path.isfile(project_file):
            shutil.copy(project_file, hidden_file)


    def _getHiddenProjectFile(self, project_file):
        index = project_file.rfind('/')
        return project_file[:index+1] + '.' + project_file[index+1:]


if __name__ == '__main__':
    scnprojectsetup = ProjectSetup()
